package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"
	"post-comment-app/graph/model"
	"strconv"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, allowComments bool) (*model.Post, error) {
	r.mu.Lock()
	id := strconv.Itoa(r.postIDCounter)
	r.postIDCounter++
	r.mu.Unlock()

	post := &model.Post{
		ID:            id,
		Title:         title,
		Content:       content,
		AllowComments: allowComments,
	}
	r.mu.Lock()
	r.Posts = append(r.Posts, post)
	r.mu.Unlock()
	return post, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, parentID *string, text string) (*model.Comment, error) {
	if len(text) > 2000 {
		return nil, fmt.Errorf("comment text too long (max 2000 chars)")
	}

	r.mu.Lock()
	var postExists bool
	for _, post := range r.Posts {
		if post.ID == postID {
			postExists = true
			break
		}
	}
	if !postExists {
		r.mu.Unlock()
		return nil, fmt.Errorf("post with ID %s not found", postID)
	}

	id := strconv.Itoa(r.commentIDCounter)
	r.commentIDCounter++
	r.mu.Unlock()

	comment := &model.Comment{
		ID:       id,
		PostID:   postID,
		ParentID: parentID,
		Text:     text,
	}

	r.mu.Lock()
	r.Comments = append(r.Comments, comment)
	r.mu.Unlock()
	return comment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: Posts - posts"))
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	r.mu.Lock()
	defer r.mu.Unlock()
	for _, original := range r.Posts {
		if original.ID == id {
			copy := &model.Post{
				ID:            original.ID,
				Title:         original.Title,
				Content:       original.Content,
				AllowComments: original.AllowComments,
			}
			copy.Comments = r.buildCommentTree(copy.ID, nil, r.Comments)
			return copy, nil
		}
	}
	return nil, fmt.Errorf("post not found")
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	panic(fmt.Errorf("not implemented: CommentAdded - commentAdded"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
