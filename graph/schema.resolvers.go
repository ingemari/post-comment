package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"
	"log"
	"post-comment-app/graph/model"
	"time"

	"github.com/google/uuid"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, author string, allowComments bool) (*model.Post, error) {
	post := &model.Post{
		ID:            uuid.NewString(),
		Title:         title,
		Content:       content,
		Author:        author,
		AllowComments: allowComments,
		CreatedAt:     time.Now().Format(time.RFC3339),
	}
	if err := r.storage.CreatePost(ctx, post); err != nil {
		return nil, err
	}
	return post, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, parentID *string, author string, text string) (*model.Comment, error) {
	log.Printf("Adding comment to postID: %s, parentID: %v", postID, parentID)

	// Поиск поста через storage
	post, err := r.storage.GetPost(ctx, postID)
	if err != nil {
		log.Printf("Error getting post: %v", err)
		return nil, fmt.Errorf("post not found")
	}
	if !post.AllowComments {
		log.Println("Comments are not allowed for this post")
		return nil, fmt.Errorf("comments are not allowed for this post")
	}

	// Проверка длины комментария
	if len(text) > 2000 {
		log.Println("Comment too long")
		return nil, fmt.Errorf("comment too long")
	}

	// Проверка parentID, если указан
	if parentID != nil {
		_, err := r.storage.GetComment(ctx, *parentID)
		if err != nil {
			log.Printf("Error getting parent comment: %v", err)
			return nil, fmt.Errorf("parent comment not found")
		}
	}

	// Создание комментария
	comment := &model.Comment{
		ID:        uuid.NewString(),
		PostID:    postID,
		ParentID:  parentID,
		Author:    author,
		Text:      text,
		CreatedAt: time.Now().Format(time.RFC3339),
	}

	// Сохранение комментария через storage
	if err := r.storage.CreateComment(ctx, comment); err != nil {
		log.Printf("Error creating comment: %v", err)
		return nil, err
	}

	// Отправляем уведомления подписчикам
	r.mu.RLock()
	defer r.mu.RUnlock()
	if subs, ok := r.subscribers[postID]; ok {
		for _, ch := range subs {
			select {
			case ch <- comment:
				log.Printf("Sent notification for comment %s to subscriber", comment.ID)
			default:
				log.Printf("Skipped notification for comment %s: channel full", comment.ID)
			}
		}
	}

	log.Printf("Comment %s created successfully", comment.ID)
	return comment, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	return r.storage.GetPosts(ctx)
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	log.Printf("Fetching post with ID: %s", id)
	post, err := r.storage.GetPost(ctx, id)
	if err != nil {
		log.Printf("Error fetching post: %v", err)
		return nil, err
	}
	log.Printf("Post %s fetched successfully", id)
	return post, nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	log.Printf("Fetching comment with ID: %s", id)
	comment, err := r.storage.GetComment(ctx, id)
	if err != nil {
		log.Printf("Error fetching comment: %v", err)
		return nil, err
	}
	log.Printf("Comment %s fetched successfully", id)
	return comment, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	log.Printf("New subscription for postID: %s", postID)
	ch := make(chan *model.Comment, 1) // буфер 1, чтобы не блокироваться

	// Добавляем канал в подписчики с синхронизацией
	r.mu.Lock()
	r.subscribers[postID] = append(r.subscribers[postID], ch)
	r.mu.Unlock()

	// При закрытии контекста удаляем канал
	go func() {
		<-ctx.Done()
		log.Printf("Cleaning up subscription for postID: %s", postID)
		r.mu.Lock()
		defer r.mu.Unlock()
		subs := r.subscribers[postID]
		for i, subscriber := range subs {
			if subscriber == ch {
				r.subscribers[postID] = append(subs[:i], subs[i+1:]...)
				break
			}
		}
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	type PostResolver interface {
	Comments(ctx context.Context, obj *model.Post, limit *int32, offset *int32) ([]*model.Comment, error)
}
type CommentResolver interface {
	Replies(ctx context.Context, obj *model.Comment, limit *int32, offset *int32) ([]*model.Comment, error)
}
func (r *Resolver) Post() PostResolver { return &postResolver{r} }
type postResolver struct{ *Resolver }
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, limit *int32, offset *int32) ([]*model.Comment, error) {
	log.Printf("Fetching comments for postID: %s, limit: %v, offset: %v", obj.ID, limit, offset)

	lim := int32(10) // Значение по умолчанию
	off := int32(0)
	if limit != nil && *limit > 0 {
		lim = *limit
	}
	if offset != nil && *offset >= 0 {
		off = *offset
	}

	comments, err := r.storage.GetCommentsByPostID(ctx, obj.ID, int(lim), int(off))
	if err != nil {
		log.Printf("Error fetching comments: %v", err)
		return nil, err
	}
	log.Printf("Fetched %d comments for postID: %s", len(comments), obj.ID)
	return comments, nil
}
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }
type commentResolver struct{ *Resolver }
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, limit *int32, offset *int32) ([]*model.Comment, error) {
	log.Printf("Fetching replies for comment ID: %s, limit: %v, offset: %v", obj.ID, limit, offset)

	lim := int32(10)
	off := int32(0)
	if limit != nil && *limit > 0 {
		lim = *limit
	}
	if offset != nil && *offset >= 0 {
		off = *offset
	}

	replies, err := r.storage.GetRepliesByCommentID(ctx, obj.ID, int(lim), int(off))
	if err != nil {
		log.Printf("Error fetching replies: %v", err)
		return nil, err
	}
	log.Printf("Fetched %d replies for comment %s", len(replies), obj.ID)
	return replies, nil
}
*/
